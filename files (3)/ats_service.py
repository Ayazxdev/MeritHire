"""
ATS Fraud Detection Service
Port: 8004

Detects:
- White text manipulation
- Prompt injection
- Semantic manipulation
- Bot-generated resumes
"""
from fastapi import FastAPI, HTTPException
from pydantic import BaseModel
from typing import Optional
import re

app = FastAPI(title="ATS Fraud Detection Service", version="1.0.0")

class ATSRequest(BaseModel):
    application_id: int
    resume_text: str
    resume_path: str

class ATSResponse(BaseModel):
    action: str  # "OK" | "NEEDS_REVIEW" | "BLACKLIST"
    reason: Optional[str] = None
    severity: str = "none"  # "none" | "low" | "medium" | "high" | "critical"
    flags: list = []
    analysis: dict = {}

@app.post("/run", response_model=ATSResponse)
async def run_ats(request: ATSRequest):
    """
    Run ATS fraud detection on resume
    """
    try:
        flags = []
        severity = "none"
        reason = None
        action = "OK"
        
        text = request.resume_text
        
        # Detection 1: White text (hidden keywords)
        # Check for unusual Unicode characters, zero-width spaces
        suspicious_chars = ['\u200b', '\u200c', '\u200d', '\ufeff']
        white_text_count = sum(text.count(char) for char in suspicious_chars)
        
        if white_text_count > 10:
            flags.append("white_text_detected")
            severity = "high"
            reason = "Potential white text manipulation detected"
        
        # Detection 2: Prompt injection
        prompt_injection_patterns = [
            r'ignore\s+(previous|all|above)\s+instructions',
            r'system\s*:\s*you\s+are',
            r'act\s+as\s+a',
            r'pretend\s+to\s+be',
            r'<\|im_start\|>',
            r'<\|im_end\|>',
            r'\[INST\]',
            r'\[\/INST\]'
        ]
        
        for pattern in prompt_injection_patterns:
            if re.search(pattern, text, re.IGNORECASE):
                flags.append("prompt_injection")
                severity = "critical"
                reason = "Prompt injection attempt detected"
                action = "BLACKLIST"
                break
        
        # Detection 3: Excessive keyword stuffing
        # Check for repeated keywords (same word > 20 times)
        words = text.lower().split()
        from collections import Counter
        word_counts = Counter(words)
        
        max_count = 0
        stuffed_word = None
        for word, count in word_counts.items():
            if len(word) > 3 and count > max_count:  # Ignore short words
                max_count = count
                stuffed_word = word
        
        if max_count > 20:
            flags.append("keyword_stuffing")
            severity = max(severity, "medium", key=["none", "low", "medium", "high", "critical"].index)
            reason = f"Excessive keyword repetition detected: '{stuffed_word}' appears {max_count} times"
        
        # Detection 4: Bot-generated patterns
        bot_indicators = [
            "as an ai language model",
            "i don't have personal experiences",
            "i'm unable to",
            "i apologize, but",
            "certainly! here's",
            "generated by chatgpt",
            "written by gpt"
        ]
        
        text_lower = text.lower()
        for indicator in bot_indicators:
            if indicator in text_lower:
                flags.append("bot_generated")
                severity = "high"
                reason = "Resume appears to be AI-generated without human review"
                action = "NEEDS_REVIEW"
                break
        
        # Detection 5: Extremely short resume
        if len(text.strip()) < 100:
            flags.append("too_short")
            severity = max(severity, "low", key=["none", "low", "medium", "high", "critical"].index)
            reason = "Resume is unusually short"
            action = "NEEDS_REVIEW"
        
        # Detection 6: No proper structure
        # Check for basic sections (experience, education, skills)
        has_experience = bool(re.search(r'\b(experience|work|employment)\b', text, re.IGNORECASE))
        has_education = bool(re.search(r'\b(education|degree|university|college)\b', text, re.IGNORECASE))
        has_skills = bool(re.search(r'\b(skills|technologies|proficiency)\b', text, re.IGNORECASE))
        
        if not (has_experience or has_education or has_skills):
            flags.append("no_structure")
            severity = max(severity, "medium", key=["none", "low", "medium", "high", "critical"].index)
            if not reason:
                reason = "Resume lacks basic structure"
        
        # Determine final action
        if action == "OK" and severity in ["high", "critical"]:
            action = "NEEDS_REVIEW"
        
        return ATSResponse(
            action=action,
            reason=reason,
            severity=severity,
            flags=flags,
            analysis={
                "white_text_chars": white_text_count,
                "keyword_stuffing": {"word": stuffed_word, "count": max_count} if max_count > 10 else None,
                "structure_check": {
                    "has_experience": has_experience,
                    "has_education": has_education,
                    "has_skills": has_skills
                },
                "resume_length": len(text)
            }
        )
    
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"ATS detection failed: {str(e)}")


@app.get("/health")
async def health_check():
    return {"status": "healthy", "service": "ats_fraud_detection"}


if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8004)
